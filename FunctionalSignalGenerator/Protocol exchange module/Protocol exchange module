library ieee;
use ieee.std_logic_1164.all;
--use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
--use ieee.std_logic_signed.all;
entity Test is
  port (
    Clk : in std_logic;
    nRst : in std_logic;
    --входная Fifo
    q_input : in std_logic_vector (15 downto 0);
    usedw_input : in std_logic_vector (10 downto 0);
    rdreq_output : out std_logic;
    --входная Fifo
    data_output : out std_logic_vector (15 downto 0);
    wrreq_output : out std_logic;
    --WISHBONE
    WB_Addr : out std_logic_vector (15 downto 0);
    WB_DataOut : out std_logic_vector (15 downto 0);
    WB_DataIn_0 : in std_logic_vector (15 downto 0);
    WB_WE : out std_logic;--Сигнал разрешения записи
    WB_Sel : out std_logic_vector (1 downto 0);--Select
    WB_STB : out std_logic;--корректность данных
    WB_Cyc_0 : out std_logic_vector (1 downto 0);--сигналом выбора ведомого устройства
    WB_Ack : in std_logic;--подтверждения штатного завершения пересылки элемента пакета
    WB_CTI : out std_logic_vector (2 downto 0)-- “000” — обычный цикл;
    -- “001” — пакетный цикл с фиксированным адресом;
    -- “010” — пакетный цикл с инкрементируемым адресом;
    -- “011-110” — зарезервировано;
    -- “111” — последний пакет
  );
end entity;
architecture rtl of Test is
  type current_type is (state_wait, header_read, addres_check, header_analysis, header_transfer, data_transfer, error_handling);
  signal header_word_left : std_logic_vector(2 downto 1);
  signal current_state : current_type;
  signal double_write : std_logic;
  signal read_s : std_logic;
  signal write_s : std_logic;
  --signal used_words : std_logic_vector(10 downto 0);
  signal byte_left : std_logic_vector(9 downto 0);
  signal data_r : std_logic_vector (15 downto 0);
  signal Cmd : std_logic_vector(2 downto 0);
  signal FB : std_logic;
  signal R1 : std_logic_vector(1 downto 0);
  signal BCount : std_logic_vector (9 downto 0);
  signal TID : std_logic_vector (7 downto 0);
  signal AddrValid : std_logic_vector (2 downto 0);
  signal R2 : std_logic_vector(4 downto 0);
  signal Addr : std_logic_vector (15 downto 0);
  signal Addr_write : std_logic_vector (15 downto 0);

begin
  process (Clk, nRst) begin
    if (nRst = '0') then
      --used_words <= (others => '0');
      byte_left <= (others => '0');
      data_r <= (others => '0');
      Cmd <= (others => '0');
      FB <= '0';
      R1 <= (others => '0');
      BCount <= (others => '0');
      TID <= (others => '0');
      AddrValid <= (others => '0');
      R2 <= (others => '0');
      Addr <= (others => '0');
      current_state <= state_wait;

    elsif (rising_edge(Clk)) then
      case current_state is
        when state_wait =>
          if (usedw_input > 2) then
            current_state <= header_read;
          end if;

        when header_read =>
          if (header_word_left = B"00") then
            current_state <= addres_check;
          end if;

        when header_analysis =>
          if (FB = '0' and AddrValid = B"000") then
            if (Cmd = B"010" or Cmd = B"100" or Cmd = B"110") then
              current_state <= data_transfer;
            else
              current_state <= header_transfer;
            end if;
          else
            current_state <= header_transfer;
          end if;

        when header_transfer =>
          if (double_write = '1') then
            current_state <= header_transfer;
          elsif (AddrValid = B"000")then
            current_state <= data_transfer;
          else
            current_state <= error_handling;
          end if;

        when data_transfer =>
          if (byte_left = 0 or byte_left = 1023) then
            current_state <= state_wait;
          end if;

        when error_handling =>
          if (byte_left = 0 or byte_left = 1023) then
            current_state <= state_wait;
          end if;
      end case;

    end if;
  end process;
  -----------------------------------------------------------------------------------------------------------------------------------------
  process (Clk) begin
    if (rising_edge(Clk)) then

      if (current_state = header_read) then
        if (header_word_left = B"00") then
          header_word_left <= B"11";
          read_s <= '1';
        else
          if (header_word_left = B"11") then
            Cmd <= data_r(2 downto 0);
            FB <= data_r(3);
            R1 <= data_r(5 downto 4);
            BCount <= data_r(15 downto 6);
            byte_left <= BCount;
          elsif (header_word_left = B"10") then
            TID <= data_r(7 downto 0);
            AddrValid <= data_r(10 downto 8);
            R2 <= data_r(15 downto 11);
          elsif (header_word_left = B"01") then
            Addr <= data_r;
            read_s <= '0';
          end if;
        end if;
        header_word_left <= header_word_left - B"01";

      elsif (current_state = addres_check) then
        if (Addr < X"0100") then--256
          Addr_write <= Addr;
          AddrValid <= B"000";
        elsif (Addr > X"00FF" and Addr < X"0200") then--256
          Addr_write <= Addr - X"0100";
          AddrValid <= B"000";
        elsif (Addr > X"01FF" and Addr < X"0300") then--256
          Addr_write <= Addr - X"0200";
          AddrValid <= B"000";
        elsif (Addr > X"02FF" and Addr < X"0FFF") then--256
          Addr_write <= Addr - X"0300";
          AddrValid <= B"000";
        elsif (Addr > X"03FF" and Addr < X"1000") then--15K
          Addr <= X"3C00";
          AddrValid <= B"110";
        elsif (Addr > X"0FFF" and Addr < X"1800") then--2K
          Addr <= X"0800";
          AddrValid <= B"001";
        else --46K
          Addr <= X"B800";
          AddrValid <= B"110";
        end if;
        current_state <= header_analysis;
      end if;

    end if;
  end process;
  ----------------------------------------------------------------------------------------------------------------------
  process (Clk) begin--Fifo transfer
    if (rising_edge(Clk)) then
      if (read_s = '1') then
        rdreq_output <= read_s;
        data_r <= q_input;
      end if;
      if (write_s = '1') then
        wrreq_output <= write_s;
        data_output <= data_r;
      end if;
    end if;
  end process;
end architecture;

